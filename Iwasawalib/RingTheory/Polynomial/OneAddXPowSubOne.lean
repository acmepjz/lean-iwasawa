/-
Copyright (c) 2025 Jz Pan. All rights reserved.
Released under Apache 2.0 license as described in the file LICENSE.
Authors: Jz Pan
-/
import Mathlib.Data.Nat.Multiplicity
import Mathlib.RingTheory.Ideal.BigOperators
import Mathlib.RingTheory.Polynomial.Eisenstein.Distinguished

/-!

# Polynomial `(1 + X) ^ n - 1`

This file contains results on polynomial `(1 + X) ^ n - 1`. Mathematically, it is viewed as
the multiply-by-`n` map `[n]` of the formal multiplicative group $\widehat{\mathbb{G}}_m$.
In particular, `(1 + X) ^ p ^ n - 1` is a distinguished polynomial at `p`,
and the ideal generated by `p ^ m` and it are cofinal with `(p ^ m, X ^ n)`
(`Polynomial.oneAddXPowSubOne_mem_span_natCast_X_pow` and
`Polynomial.span_natCast_X_pow_le_span_natCast_pow_oneAddXPowSubOne`).

-/

namespace Polynomial

variable (R : Type*) (p : ℕ) [Fact p.Prime] (n : ℕ)

section Semiring

variable [Semiring R]

/-- The `Polynomial.oneAddXPowSubOne R n` is the polynomial `(1 + X) ^ n - 1` in `R[X]`
(`Polynomial.oneAddXPowSubOne_def`). Since we allow `R` to be a `Semiring`, its actual definition
is `∑ i ∈ [1, n + 1), X ^ i * n.choose i`. -/
noncomputable def oneAddXPowSubOne := ∑ i ∈ Finset.Ico 1 (n + 1), X ^ i * (n.choose i : R[X])

@[simp]
theorem oneAddXPowSubOne_zero : oneAddXPowSubOne R 0 = 0 := by
  simp [oneAddXPowSubOne]

@[simp]
theorem oneAddXPowSubOne_one : oneAddXPowSubOne R 1 = X := by
  simp [oneAddXPowSubOne]

theorem oneAddXPowSubOne_eq_map :
    oneAddXPowSubOne R n = (oneAddXPowSubOne ℕ n).map (algebraMap ℕ R) := by
  simp [oneAddXPowSubOne, Polynomial.map_sum]

theorem commute_oneAddXPowSubOne (p : R[X]) : Commute (oneAddXPowSubOne R n) p :=
  .sum_left _ _ _ fun _ _ ↦ .mul_left (commute_X_pow _ _) (Nat.cast_commute _ _)

theorem coeff_oneAddXPowSubOne_eq (i : ℕ) :
    (oneAddXPowSubOne R n).coeff i = if i = 0 then 0 else (n.choose i : R) := by
  simp_rw [oneAddXPowSubOne, finset_sum_coeff, ← C_eq_natCast, coeff_mul_C, coeff_X_pow,
    ite_mul, one_mul, zero_mul, Finset.sum_ite_eq, Finset.mem_Ico]
  split_ifs with h1 h2 h2
  · linarith only [h1.1, h2]
  · rfl
  · rfl
  · rw [not_and, not_lt] at h1
    simp [Nat.choose_eq_zero_of_lt (h1 (Nat.pos_of_ne_zero h2))]

theorem coeff_oneAddXPowSubOne_eq_one_of_ne_zero (hn : n ≠ 0) :
    (oneAddXPowSubOne R n).coeff n = 1 := by
  simp [coeff_oneAddXPowSubOne_eq, if_neg hn]

theorem degree_oneAddXPowSubOne_of_ne_zero [Nontrivial R] (hn : n ≠ 0) :
    (oneAddXPowSubOne R n).degree = n := by
  refine degree_eq_of_le_of_coeff_ne_zero ?_
    (by simp [coeff_oneAddXPowSubOne_eq_one_of_ne_zero R n hn])
  have h1 : oneAddXPowSubOne R n = ∑ i : Fin (n + 1),
      C (if i.1 = 0 then 0 else (n.choose i.1 : R)) * X ^ i.1 := by
    rw [oneAddXPowSubOne]
    trans ∑ i ∈ Finset.range (n + 1), X ^ i * if i = 0 then 0 else (n.choose i : R[X])
    · simp_rw [Finset.range_eq_Ico, Finset.sum_eq_sum_Ico_succ_bot (show 0 < n + 1 by simp),
        if_pos, mul_zero, zero_add]
      congr! 3 with i hi
      rw [Finset.mem_Ico] at hi
      rw [if_neg (show i ≠ 0 by linarith only [hi.1])]
    rw [Finset.sum_range]
    congr! 1 with i
    rw [(commute_X_pow _ i.1).eq]
    congr 1
    split_ifs <;> simp
  have h2 : (oneAddXPowSubOne R n).degree < n + 1 := by
    rw [h1]
    exact degree_sum_fin_lt _
  have h3 (m : WithBot ℕ) (hm : m < n + 1) : m ≤ n := by
    rcases m with ⟨⟩ | m
    · nofun
    · have : m < n + 1 := WithBot.coe_lt_coe.1 hm
      exact WithBot.coe_le_coe.2 (Nat.lt_add_one_iff.1 this)
  exact h3 _ h2

theorem natDegree_oneAddXPowSubOne [Nontrivial R] : (oneAddXPowSubOne R n).natDegree = n := by
  rcases eq_or_ne n 0 with rfl | hn
  · simp
  exact natDegree_eq_of_degree_eq_some (degree_oneAddXPowSubOne_of_ne_zero R n hn)

theorem monic_oneAddXPowSubOne_of_ne_zero (hn : n ≠ 0) : (oneAddXPowSubOne R n).Monic := by
  rcases subsingleton_or_nontrivial R with _ | _
  · exact monic_of_subsingleton _
  rw [Monic, leadingCoeff, natDegree_oneAddXPowSubOne,
    coeff_oneAddXPowSubOne_eq_one_of_ne_zero _ _ hn]

end Semiring

section Ring

variable [Ring R]

theorem oneAddXPowSubOne_def : oneAddXPowSubOne R n = (1 + X) ^ n - 1 := by
  rw [add_comm, (commute_X 1).add_pow, oneAddXPowSubOne, Finset.range_eq_Ico,
    Finset.sum_eq_sum_Ico_succ_bot (show 0 < n + 1 by simp)]
  simp

end Ring

section Semiring

variable [Semiring R]

theorem oneAddXPowSubOne_mul_geom_sum (m : ℕ) :
    oneAddXPowSubOne R n * ∑ i ∈ Finset.range m, (1 + X) ^ (n * i) =
      oneAddXPowSubOne R (n * m) := by
  suffices oneAddXPowSubOne ℕ n * ∑ i ∈ Finset.range m, (1 + X) ^ (n * i) =
      oneAddXPowSubOne ℕ (n * m) by
    simp_rw [oneAddXPowSubOne_eq_map R, ← this, Polynomial.map_mul, Polynomial.map_sum,
      Polynomial.map_pow, Polynomial.map_add, Polynomial.map_one, Polynomial.map_X]
  suffices oneAddXPowSubOne ℤ n * ∑ i ∈ Finset.range m, (1 + X) ^ (n * i) =
      oneAddXPowSubOne ℤ (n * m) by
    apply_fun map (algebraMap ℕ ℤ) using map_injective _ CharZero.cast_injective
    simp_rw [Polynomial.map_mul, Polynomial.map_sum, Polynomial.map_pow, Polynomial.map_add,
      Polynomial.map_one, Polynomial.map_X, ← oneAddXPowSubOne_eq_map, this]
  simpa [oneAddXPowSubOne_def, pow_mul] using
    (Commute.one_right ((1 + X) ^ n : ℤ[X])).mul_geom_sum₂ m

theorem oneAddXPowSubOne_dvd_of_dvd (m : ℕ) (h : n ∣ m) :
    oneAddXPowSubOne R n ∣ oneAddXPowSubOne R m := by
  obtain ⟨m, rfl⟩ := h
  exact Dvd.intro _ (oneAddXPowSubOne_mul_geom_sum R n m)

theorem X_dvd_oneAddXPowSubOne : X ∣ oneAddXPowSubOne R n := by
  simpa using oneAddXPowSubOne_dvd_of_dvd R 1 n (by simp)

theorem dvd_coeff_oneAddXPowSubOne_of_ne (i : ℕ) (hi : i ≠ p ^ n) :
    (p : R) ∣ (oneAddXPowSubOne R (p ^ n)).coeff i := by
  rw [coeff_oneAddXPowSubOne_eq]
  split_ifs with h
  · simp
  obtain ⟨q, hq⟩ := (Fact.out : p.Prime).dvd_choose_pow h hi
  use q
  simp [hq]

omit [Fact p.Prime] in
theorem oneAddXPowSubOne_mem_span_natCast_X_pow :
    oneAddXPowSubOne R (p ^ n) ∈ Ideal.span {(p : R[X]), X} ^ (n + 1) := by
  induction n with
  | zero =>
    rw [zero_add, pow_zero, oneAddXPowSubOne_one, Submodule.pow_one, Ideal.mem_span_pair]
    exact ⟨0, 1, by simp⟩
  | succ n ih =>
    rw [Submodule.pow_succ, pow_succ, ← oneAddXPowSubOne_mul_geom_sum]
    refine Ideal.mul_mem_mul ih ?_
    rw [(∑ i ∈ Finset.range p, (1 + X) ^ (p ^ n * i)).as_sum_support_C_mul_X_pow]
    refine Ideal.sum_mem _ fun j _ ↦ ?_
    rcases eq_or_ne j 0 with rfl | hj
    · simp only [finset_sum_coeff, pow_zero, mul_one, coeff_one_add_X_pow,
        Nat.choose_zero_right, Nat.cast_one, Finset.sum_const, Finset.card_range,
        nsmul_eq_mul, map_natCast, Ideal.mem_span_pair]
      exact ⟨1, 0, by simp⟩
    apply Ideal.mul_mem_left
    rw [Ideal.mem_span_pair]
    exact ⟨0, X ^ (j - 1), by simp [← pow_succ, Nat.sub_one_add_one hj]⟩

theorem test1_isTwoSided (Y : R[X]) (hY : ∀ q : R[X], Commute Y q)
    (Z : R[X]) (hZ : ∀ q : R[X], Commute Z q) :
    (Ideal.span {Y, Z}).IsTwoSided := by
  refine ⟨fun {a} b ha ↦ ?_⟩
  rw [Ideal.mem_span_pair] at ha ⊢
  obtain ⟨x, y, rfl⟩ := ha
  refine ⟨x * b, y * b, ?_⟩
  simp_rw [add_mul, mul_assoc, (hY b).eq, (hZ b).eq]

theorem test1_le (m : ℕ) (hm : m ≠ 0) (Y : R[X]) (hY : ∀ q : R[X], Commute Y q)
    (Z : R[X]) (hZ : ∀ q : R[X], Commute Z q) :
    Ideal.span {Y, Z} ^ m ≤ Ideal.span {Y, Z ^ m} := by
  have := test1_isTwoSided R Y hY Z hZ
  rw [← Nat.one_le_iff_ne_zero] at hm
  induction hm with
  | refl => simp [Submodule.pow_one]
  | step hm ih =>
    rename_i m
    rw [Ideal.IsTwoSided.pow_succ]
    intro x hx
    refine Submodule.smul_induction_on hx (fun y hy z hz ↦ ?_) fun _ _ hy hz ↦ add_mem hy hz
    replace hz := ih hz
    rw [Ideal.mem_span_pair] at hy hz ⊢
    obtain ⟨y1, y2, rfl⟩ := hy
    obtain ⟨z1, z2, rfl⟩ := hz
    use y1 * z1 * Y + y1 * z2 * Z ^ m + y2 * z1 * Z, y2 * z2
    simp_rw [Nat.succ_eq_add_one, smul_eq_mul, add_mul, mul_add]
    conv_rhs =>
      congr
      · congr
        · rw [mul_assoc, (hY _).eq, ← mul_assoc, ← mul_assoc]
        · rw [mul_assoc, (hY _).eq, ← mul_assoc, ← mul_assoc]
      · congr
        · rw [mul_assoc, (hZ _).eq, mul_assoc, ← (hZ _).eq, ← mul_assoc, ← mul_assoc]
        · rw [mul_assoc, ← mul_assoc Z z2, (hZ _).eq, mul_assoc, ← pow_succ', ← mul_assoc]
    rw [← add_assoc]

end Semiring

section Ring

variable [Ring R]

theorem X_pow_natCast_pow_mem_span_natCast_oneAddXPowSubOne :
    X ^ (p ^ n) ∈ Ideal.span {(p : R[X]), oneAddXPowSubOne R (p ^ n)} := by
  have hp := (Fact.out : p.Prime).ne_zero
  rcases subsingleton_or_nontrivial R with _ | _
  · simp [Subsingleton.elim (X ^ (p ^ n)) 0]
  rw [Ideal.mem_span_pair]
  have h := (oneAddXPowSubOne R (p ^ n)).as_sum_range_C_mul_X_pow
  rw [natDegree_oneAddXPowSubOne, Finset.sum_range_succ,
    coeff_oneAddXPowSubOne_eq_one_of_ne_zero _ _ (by simp [hp]), map_one, one_mul] at h
  have h2 (i) (hi : i ∈ Finset.range (p ^ n)) := dvd_coeff_oneAddXPowSubOne_of_ne R p n i
    (Finset.mem_range.1 hi).ne
  choose c hc using h2
  use -∑ i ∈ Finset.range (p ^ n), C (if hi : i ∈ Finset.range (p ^ n) then c i hi else 0) * X ^ i
  use 1
  rw [one_mul, h, ← add_assoc, add_eq_right, neg_mul, neg_add_eq_zero, Finset.sum_mul]
  congr! 1 with i hi
  rw [← (Nat.cast_commute _ _).eq, ← mul_assoc, dif_pos hi, hc i hi, map_mul, map_natCast]

theorem span_natCast_X_pow_natCast_pow_le_span_natCast_oneAddXPowSubOne :
    Ideal.span {(p : R[X]), X} ^ (p ^ n) ≤ Ideal.span {(p : R[X]), oneAddXPowSubOne R (p ^ n)} := by
  refine (test1_le R (p ^ n) (by simp [(Fact.out : p.Prime).ne_zero])
    p (Nat.cast_commute _) X commute_X).trans ?_
  simp_rw [Ideal.span_le, Set.insert_subset_iff, Set.singleton_subset_iff, SetLike.mem_coe]
  refine ⟨?_, X_pow_natCast_pow_mem_span_natCast_oneAddXPowSubOne R p n⟩
  rw [Ideal.mem_span_pair]
  exact ⟨1, 0, by simp⟩

theorem _root_.Ideal.IsTwoSided.pow_mul {R : Type*} [Semiring R] {I : Ideal R} [I.IsTwoSided]
    (m n : ℕ) : I ^ (m * n) = (I ^ m) ^ n := by
  induction n with
  | zero => simp [Submodule.pow_zero]
  | succ n ih =>
    rw [mul_add, mul_one, Ideal.IsTwoSided.pow_add, Ideal.IsTwoSided.pow_add, ih, Submodule.pow_one]

theorem span_natCast_X_pow_le_span_natCast_pow_oneAddXPowSubOne
    (m k : ℕ) (hm : m ≠ 0) (hk : k ≥ p ^ n * m) :
    Ideal.span {(p : R[X]), X} ^ k ≤ Ideal.span {(p ^ m : R[X]), oneAddXPowSubOne R (p ^ n)} := by
  have := test1_isTwoSided R p (Nat.cast_commute _) X commute_X
  refine (Ideal.pow_le_pow_right hk).trans ?_
  rw [Ideal.IsTwoSided.pow_mul]
  refine Ideal.pow_right_mono
    (span_natCast_X_pow_natCast_pow_le_span_natCast_oneAddXPowSubOne R p n) m |>.trans ?_
  simp_rw [Set.pair_comm _ (oneAddXPowSubOne R _)]
  exact test1_le R m hm _ (commute_oneAddXPowSubOne R _) p (Nat.cast_commute _)

end Ring

section CommRing

variable [CommRing R]

theorem isDistinguishedAt_oneAddXPowSubOne :
    (oneAddXPowSubOne R (p ^ n)).IsDistinguishedAt (Ideal.span {(p : R)}) where
  mem {i} hi := by
    rcases subsingleton_or_nontrivial R with _ | _
    · simp [natDegree_of_subsingleton] at hi
    rw [natDegree_oneAddXPowSubOne] at hi
    rw [Ideal.mem_span_singleton]
    exact dvd_coeff_oneAddXPowSubOne_of_ne R _ _ _ hi.ne
  monic := monic_oneAddXPowSubOne_of_ne_zero R _ (by simp [(Fact.out : p.Prime).ne_zero])

end CommRing

end Polynomial
